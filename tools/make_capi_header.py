# Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.

from cef_parser import *

def make_capi_global_funcs(funcs, defined_names, translate_map, indent):
    result = ''
    first = True
    for func in funcs:
        comment = func.get_comment()
        if first or len(comment) > 0:
            result += '\n'+format_comment(comment, indent, translate_map);
        if func.get_retval().get_type().is_result_string():
            result += indent+'// The resulting string must be freed by calling cef_string_userfree_free().\n'
        result += wrap_code(indent+'CEF_EXPORT '+
                            func.get_capi_proto(defined_names)+';')
        if first:
            first = False
    return result

def make_capi_member_funcs(funcs, defined_names, translate_map, indent):
    result = ''
    first = True
    for func in funcs:
        comment = func.get_comment()
        if first or len(comment) > 0:
            result += '\n'+format_comment(comment, indent, translate_map)
        if func.get_retval().get_type().is_result_string():
            result += indent+'// The resulting string must be freed by calling cef_string_userfree_free().\n'
        parts = func.get_capi_parts()
        result += wrap_code(indent+parts['retval']+' (CEF_CALLBACK *'+
                            parts['name']+')('+
                            string.join(parts['args'], ', ')+');')
        if first:
            first = False
    return result

def make_capi_header(header):
    # structure names that have already been defined
    defined_names = header.get_defined_structs()
    
    # map of strings that will be changed in C++ comments
    translate_map = header.get_capi_translations()
    
    # header string
    result = \
"""// Copyright (c) 2011 Marshall A. Greenblatt. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//

#ifndef _CEF_CAPI_H
#define _CEF_CAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#include "cef_export.h"
#include "cef_string.h"
#include "cef_string_list.h"
#include "cef_string_map.h"
#include "cef_types.h"

"""

    # output global functions
    result += make_capi_global_funcs(header.get_funcs(), defined_names,
                                     translate_map, '')
    
    # before classes string
    result += \
"""
typedef struct _cef_base_t
{
  // Size of the data structure.
  size_t size;

  // Increment the reference count.
  int (CEF_CALLBACK *add_ref)(struct _cef_base_t* self);
  // Decrement the reference count.  Delete this object when no references
  // remain.
  int (CEF_CALLBACK *release)(struct _cef_base_t* self);
  // Returns the current number of references.
  int (CEF_CALLBACK *get_refct)(struct _cef_base_t* self);

} cef_base_t;


// Check that the structure |s|, which is defined with a cef_base_t member named
// |base|, is large enough to contain the specified member |f|.
#define CEF_MEMBER_EXISTS(s, f)   \\
  ((int)&((s)->f) - (int)(s) + sizeof((s)->f) <= (s)->base.size)

#define CEF_MEMBER_MISSING(s, f)  (!CEF_MEMBER_EXISTS(s, f) || !((s)->f))

"""
    
    # output classes
    classes = header.get_classes()
    for cls in classes:
        # virtual functions are inside the structure
        classname = cls.get_capi_name()
        result += '\n'+format_comment(cls.get_comment(), '', translate_map);
        result += 'typedef struct _'+classname+ \
                  '\n{\n  // Base structure.\n  cef_base_t base;\n'
        funcs = cls.get_virtual_funcs()
        result += make_capi_member_funcs(funcs, defined_names,
                                         translate_map, '  ')
        result += '\n} '+classname+';\n\n'
        
        defined_names.append(cls.get_capi_name())
        
        # static functions become global
        funcs = cls.get_static_funcs()
        if len(funcs) > 0:
            result += make_capi_global_funcs(funcs, defined_names,
                                             translate_map, '')+'\n'
    
    # footer string
    result += \
"""
#ifdef __cplusplus
}
#endif

#endif // _CEF_CAPI_H
"""
    
    return result


def write_capi_header(header, file, backup):
    if file_exists(file):
        oldcontents = read_file(file)
    else:
        oldcontents = ''
    
    newcontents = make_capi_header(header)
    if newcontents != oldcontents:
        if backup and oldcontents != '':
            backup_file(file)
        write_file(file, newcontents)
        return True
    
    return False


# test the module
if __name__ == "__main__":
    import sys
    
    # verify that the correct number of command-line arguments are provided
    if len(sys.argv) < 2:
        sys.stderr.write('Usage: '+sys.argv[0]+' <infile>')
        sys.exit()
        
    # create the header object
    header = obj_header(sys.argv[1])
    
    # dump the result to stdout
    sys.stdout.write(make_capi_header(header))
