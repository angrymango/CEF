# Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.

from cef_parser import *

def make_cpptoc_header(header, clsname):
    cls = header.get_class(clsname)
    if cls is None:
        raise Exception('Class does not exist: '+clsname)
    
    dllside = cls.is_library_side()
    defname = string.upper(clsname[3:])
    capiname = cls.get_capi_name()
    
    result = \
"""// Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
"""
    result += '#ifndef _'+defname+'_CPPTOC_H\n'+ \
              '#define _'+defname+'_CPPTOC_H\n'
    
    if dllside:
        result += """
#ifndef BUILDING_CEF_SHARED
#pragma message("Warning: "__FILE__" may be accessed DLL-side only")
#else // BUILDING_CEF_SHARED
"""
    else:
        result += """
#ifndef USING_CEF_SHARED
#pragma message("Warning: "__FILE__" may be accessed wrapper-side only")
#else // USING_CEF_SHARED
"""

    result += """
#include "include/cef.h"
#include "include/cef_capi.h"
#include "libcef_dll/cpptoc/cpptoc.h"

// Wrap a C++ class with a C structure.
"""

    if dllside:
        result += '// This class may be instantiated and accessed DLL-side only.\n'
    else:
        result += '// This class may be instantiated and accessed wrapper-side only.\n'
    
    result +=  'class '+clsname+'CppToC\n'+ \
               '    : public CefCppToC<'+clsname+'CppToC, '+clsname+', '+capiname+'>\n'+ \
               '{\n'+ \
               'public:\n'+ \
               '  '+clsname+'CppToC('+clsname+'* cls);\n'+ \
               '  virtual ~'+clsname+'CppToC() {}\n'+ \
               '};\n\n'
    
    if dllside:
        result += '#endif // BUILDING_CEF_SHARED\n'
    else:
        result += '#endif // USING_CEF_SHARED\n'
    
    result += '#endif // _'+defname+'_CPPTOC_H\n'
    
    return wrap_code(result)


def write_cpptoc_header(header, clsname, dir, backup):
    file = dir+os.sep+get_capi_name(clsname[3:], False)+'_cpptoc.h'
    
    if file_exists(file):
        oldcontents = read_file(file)
    else:
        oldcontents = ''
    
    newcontents = make_cpptoc_header(header, clsname)
    if newcontents != oldcontents:
        if backup and oldcontents != '':
            backup_file(file)
        write_file(file, newcontents)
        return True
    
    return False


# test the module
if __name__ == "__main__":
    import sys
    
    # verify that the correct number of command-line arguments are provided
    if len(sys.argv) < 3:
        sys.stderr.write('Usage: '+sys.argv[0]+' <infile> <classname>')
        sys.exit()
        
    # create the header object
    header = obj_header(sys.argv[1])
    
    # dump the result to stdout
    sys.stdout.write(make_cpptoc_header(header, sys.argv[2]))
