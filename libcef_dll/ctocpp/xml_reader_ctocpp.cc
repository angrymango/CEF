// Copyright (c) 2010 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// A portion of this file was generated by the CEF translator tool.  When
// making changes by hand only do so within the body of existing static and
// virtual method implementations. See the translator.README.txt file in the
// tools directory for more information.
//

#include "libcef_dll/ctocpp/stream_reader_ctocpp.h"
#include "libcef_dll/ctocpp/xml_reader_ctocpp.h"


// STATIC METHODS - Body may be edited by hand.

CefRefPtr<CefXmlReader> CefXmlReader::Create(CefRefPtr<CefStreamReader> stream,
    EncodingType encodingType, const std::wstring& URI)
{
  cef_xml_reader_t* impl = cef_xml_reader_create(
      CefStreamReaderCToCpp::Unwrap(stream), encodingType, URI.c_str());
  if(impl)
    return CefXmlReaderCToCpp::Wrap(impl);
  return NULL;
}


// VIRTUAL METHODS - Body may be edited by hand.

bool CefXmlReaderCToCpp::MoveToNextElement()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_next_element))
    return false;

  return struct_->move_to_next_element(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::Close()
{
  if(CEF_MEMBER_MISSING(struct_, close))
    return false;

  return struct_->close(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::HasError()
{
  if(CEF_MEMBER_MISSING(struct_, has_error))
    return false;

  return struct_->has_error(struct_) ? true : false;
}

std::wstring CefXmlReaderCToCpp::GetError()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_error))
    return str;

  cef_string_t cef_str = struct_->get_error(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

CefXmlReader::NodeType CefXmlReaderCToCpp::GetType()
{
  if(CEF_MEMBER_MISSING(struct_, get_type))
    return XML_NODE_UNSUPPORTED;

  return struct_->get_type(struct_);
}

int CefXmlReaderCToCpp::GetDepth()
{
  if(CEF_MEMBER_MISSING(struct_, get_depth))
    return -1;

  return struct_->get_depth(struct_);
}

std::wstring CefXmlReaderCToCpp::GetLocalName()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_local_name))
    return str;

  cef_string_t cef_str = struct_->get_local_name(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetPrefix()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_prefix))
    return str;

  cef_string_t cef_str = struct_->get_prefix(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetQualifiedName()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_qualified_name))
    return str;

  cef_string_t cef_str = struct_->get_qualified_name(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetNamespaceURI()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_namespace_uri))
    return str;

  cef_string_t cef_str = struct_->get_namespace_uri(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetBaseURI()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_base_uri))
    return str;

  cef_string_t cef_str = struct_->get_base_uri(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetXmlLang()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_xml_lang))
    return str;

  cef_string_t cef_str = struct_->get_xml_lang(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

bool CefXmlReaderCToCpp::IsEmptyElement()
{
  if(CEF_MEMBER_MISSING(struct_, is_empty_element))
    return false;

  return struct_->is_empty_element(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::HasValue()
{
  if(CEF_MEMBER_MISSING(struct_, has_value))
    return false;

  return struct_->has_value(struct_) ? true : false;
}

std::wstring CefXmlReaderCToCpp::GetValue()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_value))
    return str;

  cef_string_t cef_str = struct_->get_value(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

bool CefXmlReaderCToCpp::HasAttributes()
{
  if(CEF_MEMBER_MISSING(struct_, has_attributes))
    return false;

  return struct_->has_attributes(struct_) ? true : false;
}

size_t CefXmlReaderCToCpp::GetAttributeCount()
{
  if(CEF_MEMBER_MISSING(struct_, get_attribute_count))
    return 0;

  return struct_->get_attribute_count(struct_);
}

std::wstring CefXmlReaderCToCpp::GetAttribute(int index)
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_byindex))
    return str;

  cef_string_t cef_str = struct_->get_attribute_byindex(struct_, index);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetAttribute(const std::wstring& qualifiedName)
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_byqname))
    return str;

  cef_string_t cef_str = struct_->get_attribute_byqname(struct_,
      qualifiedName.c_str());
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetAttribute(const std::wstring& localName,
    const std::wstring& namespaceURI)
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_bylname))
    return str;

  cef_string_t cef_str = struct_->get_attribute_bylname(struct_,
      localName.c_str(), namespaceURI.c_str());
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetInnerXml()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_inner_xml))
    return str;

  cef_string_t cef_str = struct_->get_inner_xml(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

std::wstring CefXmlReaderCToCpp::GetOuterXml()
{
  std::wstring str;
  if(CEF_MEMBER_MISSING(struct_, get_outer_xml))
    return str;

  cef_string_t cef_str = struct_->get_outer_xml(struct_);
  if(cef_str) {
    str = cef_str;
    cef_string_free(cef_str);
  }

  return str;
}

int CefXmlReaderCToCpp::GetLineNumber()
{
  if(CEF_MEMBER_MISSING(struct_, get_line_number))
    return false;

  return struct_->get_line_number(struct_);
}

bool CefXmlReaderCToCpp::MoveToAttribute(int index)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_byindex))
    return false;

  return struct_->move_to_attribute_byindex(struct_, index) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToAttribute(const std::wstring& qualifiedName)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_byqname))
    return false;

  return struct_->move_to_attribute_byqname(struct_, qualifiedName.c_str()) ?
      true : false;
}

bool CefXmlReaderCToCpp::MoveToAttribute(const std::wstring& localName,
    const std::wstring& namespaceURI)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_bylname))
    return false;

  return struct_->move_to_attribute_bylname(struct_, localName.c_str(),
      namespaceURI.c_str()) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToFirstAttribute()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_first_attribute))
    return false;

  return struct_->move_to_first_attribute(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToNextAttribute()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_next_attribute))
    return false;

  return struct_->move_to_next_attribute(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToCarryingElement()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_carrying_element))
    return false;

  return struct_->move_to_carrying_element(struct_) ? true : false;
}


#ifdef _DEBUG
long CefCToCpp<CefXmlReaderCToCpp, CefXmlReader, cef_xml_reader_t>::DebugObjCt =
    0;
#endif

