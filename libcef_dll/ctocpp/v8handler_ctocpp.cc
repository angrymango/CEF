// Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// A portion of this file was generated by the CEF translator tool.  When
// making changes by hand only do so within the body of existing static and
// virtual method implementations. See the translator.README.txt file in the
// tools directory for more information.
//

#include "libcef_dll/cpptoc/v8value_cpptoc.h"
#include "libcef_dll/ctocpp/v8handler_ctocpp.h"


// VIRTUAL METHODS - Body may be edited by hand.

bool CefV8HandlerCToCpp::Execute(const CefString& name,
    CefRefPtr<CefV8Value> object, const CefV8ValueList& arguments,
    CefRefPtr<CefV8Value>& retval, CefString& exception)
{
  if(CEF_MEMBER_MISSING(struct_, execute))
    return false;

  cef_v8value_t** argsStructPtr = NULL;
  int argsSize = arguments.size();
  if(argsSize > 0) {
    argsStructPtr = new cef_v8value_t*[argsSize];
    for(int i = 0; i < argsSize; ++i)
      argsStructPtr[i] = CefV8ValueCppToC::Wrap(arguments[i]);
  }

  cef_v8value_t* retvalStruct = NULL;

  int rv = struct_->execute(struct_, name.GetStruct(),
      CefV8ValueCppToC::Wrap(object), argsSize, argsStructPtr, &retvalStruct,
      exception.GetWritableStruct());
  if(retvalStruct)
    retval = CefV8ValueCppToC::Unwrap(retvalStruct);

  if(argsStructPtr)
    delete [] argsStructPtr;

  return rv ? true : false;
}


#ifndef NDEBUG
template<> long CefCToCpp<CefV8HandlerCToCpp, CefV8Handler,
    cef_v8handler_t>::DebugObjCt = 0;
#endif

